import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
import { authAPI } from '@/service/api'

export const useAuthStore = defineStore('auth', () => {
  // Estado
  const user = ref(null)
  const token = ref(null)
  const isAuthenticated = ref(false)
  const isLoading = ref(true)
  
  // Fun√ß√£o para verificar se o token est√° expirado
  const isTokenExpired = (token) => {
    if (!token) return true
    
    try {
      const payload = JSON.parse(atob(token.split('.')[1]))
      const now = Math.floor(Date.now() / 1000)
      const isExpired = payload.exp < now
      
      if (isExpired) {
        console.warn('‚ö†Ô∏è TOKEN EXPIRADO:', {
          issued: new Date(payload.iat * 1000).toLocaleString(),
          expires: new Date(payload.exp * 1000).toLocaleString(),
          now: new Date().toLocaleString(),
          timeExpired: Math.floor((now - payload.exp) / 60) + ' minutos atr√°s'
        })
      }
      
      return isExpired
    } catch (error) {
      console.error('‚ùå Erro ao verificar expira√ß√£o do token:', error)
      return true
    }
  }
  
  // Fun√ß√£o para salvar token e dados do usu√°rio
  const saveAuthData = (tokenValue, userData) => {
    console.log('üíæ AUTH STORE: Salvando dados de autentica√ß√£o...')
    
    // Atualizar estado da store
    token.value = tokenValue
    user.value = userData
    isAuthenticated.value = true
    
    // Salvar no localStorage
    localStorage.setItem('auth_token', tokenValue)
    localStorage.setItem('user_data', JSON.stringify(userData))
    
    // Verificar se foi salvo corretamente
    const savedToken = localStorage.getItem('auth_token')
    const savedUser = localStorage.getItem('user_data')
    
    console.log('‚úÖ AUTH STORE: Dados salvos:', {
      tokenInStore: !!token.value,
      tokenInLocalStorage: !!savedToken,
      tokensMatch: token.value === savedToken,
      userInStore: !!user.value,
      userInLocalStorage: !!savedUser,
      tokenLength: tokenValue?.length || 0,
      tokenStart: tokenValue?.substring(0, 30) || 'N/A'
    })
    
    // Log da expira√ß√£o do token
    if (tokenValue) {
      try {
        const payload = JSON.parse(atob(tokenValue.split('.')[1]))
        const timeLeft = Math.floor((payload.exp - Math.floor(Date.now() / 1000)) / 60)
        console.log(`‚è∞ AUTH STORE: Token expira em ${timeLeft} minutos (${new Date(payload.exp * 1000).toLocaleString()})`)
      } catch (error) {
        console.warn('N√£o foi poss√≠vel decodificar a data de expira√ß√£o do token')
      }
    }
  }
  
  // Actions
  const login = async (credentials) => {
    try {
      console.log('üîê AUTH STORE: Iniciando login para:', credentials.email)
      const response = await authAPI.login(credentials)
      
      console.log('üì• AUTH STORE: Resposta completa do login:', response.data)
      
      if (response.data.success) {
        // Buscar token em diferentes poss√≠veis localiza√ß√µes na resposta
        const possibleTokenFields = [
          'token',
          'access_token',
          'accessToken',
          'jwt',
          'authToken'
        ]
        
        let authToken = null
        let userData = null
        
        // Verificar no n√≠vel raiz
        for (const field of possibleTokenFields) {
          if (response.data[field]) {
            authToken = response.data[field]
            console.log(`‚úÖ AUTH STORE: Token encontrado em response.data.${field}`)
            break
          }
        }
        
        // Verificar no data.data se n√£o encontrou no n√≠vel raiz
        if (!authToken && response.data.data) {
          for (const field of possibleTokenFields) {
            if (response.data.data[field]) {
              authToken = response.data.data[field]
              console.log(`‚úÖ AUTH STORE: Token encontrado em response.data.data.${field}`)
              break
            }
          }
        }
        
        // Buscar dados do usu√°rio
        userData = response.data.user || 
                  response.data.data?.user ||
                  response.data.userData ||
                  response.data.data?.userData
        
        console.log('üîç AUTH STORE: Debug dos dados extra√≠dos:', {
          tokenFound: !!authToken,
          tokenLength: authToken?.length || 0,
          tokenStart: authToken?.substring(0, 30) || 'N/A',
          userFound: !!userData,
          userEmail: userData?.email || 'N/A'
        })
        
        if (!authToken) {
          console.error('‚ùå AUTH STORE: Nenhum token encontrado na resposta!')
          console.error('üìã AUTH STORE: Estrutura da resposta:', JSON.stringify(response.data, null, 2))
          throw new Error('Token n√£o recebido do servidor')
        }
        
        // Verificar se o token n√£o est√° expirado
        if (isTokenExpired(authToken)) {
          console.error('‚ùå AUTH STORE: Token recebido j√° est√° expirado!')
          throw new Error('Token expirado recebido do servidor')
        }
        
        // Salvar dados de autentica√ß√£o usando a fun√ß√£o centralizada
        saveAuthData(authToken, userData)
        
        // For√ßar atualiza√ß√£o imediata da store e localStorage para pr√≥ximas requisi√ß√µes
        await new Promise(resolve => setTimeout(resolve, 100))
        
        console.log('üéâ AUTH STORE: Login realizado com sucesso!')
        return { success: true }
      } else {
        throw new Error(response.data.message || 'Erro no login')
      }
    } catch (error) {
      console.error('üí• AUTH STORE: Erro no login:', error)
      return { 
        success: false, 
        error: error.message || 'Erro ao fazer login' 
      }
    }
  }

  const register = async (userData) => {
    try {
      isLoading.value = true
      console.log('üìù AUTH STORE: Iniciando registro...', userData)
      
      // ‚úÖ CORRIGIDO: Preparar dados conforme esperado pela API
      const registrationData = {
        name: userData.name?.trim() || '',
        email: userData.email?.trim() || '',
        phone: userData.phone?.trim() || '',
        password: userData.password || '',
        company: userData.company?.trim() || '',
        // Remover campos que n√£o s√£o enviados para API
        // confirmPassword e acceptTerms s√£o apenas para valida√ß√£o frontend
      }
      
      console.log('üì§ AUTH STORE: Dados de registro preparados:', registrationData)
      
      const response = await authAPI.register(registrationData)
      console.log('üì• AUTH STORE: Resposta do registro:', response.data)
      
      if (response.data.success || response.status === 201) {
        console.log('‚úÖ AUTH STORE: Registro realizado com sucesso')
        return { success: true, message: 'Conta criada com sucesso!' }
      } else {
        throw new Error(response.data.message || 'Erro no cadastro')
      }
    } catch (error) {
      console.error('üí• AUTH STORE: Erro no registro:', error)
      
      // ‚úÖ NOVO: Retornar erros estruturados
      if (error.response?.data?.errors && Array.isArray(error.response.data.errors)) {
        return { 
          success: false, 
          error: error.response.data.message || 'Dados de entrada inv√°lidos',
          errors: error.response.data.errors
        }
      } else {
        return { 
          success: false, 
          error: error.response?.data?.message || error.message || 'Erro ao criar conta'
        }
      }
    } finally {
      isLoading.value = false
    }
  }
  
  const logout = async () => {
    try {
      console.log('üö™ AUTH STORE: Iniciando logout...')
      // Opcional: chamar API de logout
      if (token.value) {
        await authAPI.logout()
      }
    } catch (error) {
      console.error('üí• AUTH STORE: Erro na API de logout:', error)
    } finally {
      // Sempre limpar dados locais
      clearAuthData()
    }
    
    return { success: true }
  }

  const clearAuthData = () => {
    console.log('üßπ AUTH STORE: Limpando dados de autentica√ß√£o...')
    user.value = null
    token.value = null
    isAuthenticated.value = false
    
    localStorage.removeItem('auth_token')
    localStorage.removeItem('user_data')
    localStorage.removeItem('sidebarCollapsed')
  }

  // ‚úÖ CORRE√á√ÉO PRINCIPAL: L√≥gica mais robusta para initializeAuth
  const initializeAuth = async () => {
    try {
      console.log('üöÄ AUTH STORE: Inicializando autentica√ß√£o...')
      isLoading.value = true
      
      const savedToken = localStorage.getItem('auth_token')
      const savedUser = localStorage.getItem('user_data')
      
      console.log('üîç AUTH STORE: Verifica√ß√£o inicial do localStorage:', {
        tokenExists: !!savedToken,
        tokenLength: savedToken?.length || 0,
        tokenFirst30: savedToken?.substring(0, 30) || 'N/A',
        userExists: !!savedUser,
        isTokenUndefined: savedToken === 'undefined',
        isTokenNull: savedToken === 'null'
      })
      
      // ‚úÖ FASE 1: Verificar se temos dados b√°sicos
      if (!savedToken || !savedUser || savedToken === 'undefined' || savedToken === 'null') {
        console.log('‚ùå AUTH STORE: Dados de autentica√ß√£o n√£o encontrados ou inv√°lidos')
        isLoading.value = false
        return false
      }

      // ‚úÖ FASE 2: Verificar se o token n√£o est√° expirado
      if (isTokenExpired(savedToken)) {
        console.log('‚è∞ AUTH STORE: Token expirado encontrado no localStorage')
        clearAuthData()
        isLoading.value = false
        return false
      }

      // ‚úÖ FASE 3: Restaurar dados b√°sicos primeiro (para funcionar offline)
      try {
        const parsedUser = JSON.parse(savedUser)
        token.value = savedToken
        user.value = parsedUser
        isAuthenticated.value = true
        
        console.log('‚úÖ AUTH STORE: Dados b√°sicos restaurados do localStorage')
        
        // Log da expira√ß√£o do token
        try {
          const payload = JSON.parse(atob(savedToken.split('.')[1]))
          const timeLeft = Math.floor((payload.exp - Math.floor(Date.now() / 1000)) / 60)
          console.log(`‚è∞ AUTH STORE: Token expira em ${timeLeft} minutos`)
        } catch (error) {
          console.warn('N√£o foi poss√≠vel decodificar a data de expira√ß√£o do token')
        }
      } catch (parseError) {
        console.error('üí• AUTH STORE: Erro ao fazer parse dos dados do usu√°rio:', parseError)
        clearAuthData()
        isLoading.value = false
        return false
      }

      // ‚úÖ FASE 4: Verificar com o servidor (mas sem deslogar se falhar)
      try {
        console.log('üîç AUTH STORE: Verificando validade do token com o servidor...')
        const response = await authAPI.me()
        
        if (response.data.success && response.data.user) {
          console.log('‚úÖ AUTH STORE: Token validado pelo servidor')
          // Atualizar dados do usu√°rio se necess√°rio
          user.value = response.data.user
          localStorage.setItem('user_data', JSON.stringify(user.value))
        } else {
          console.warn('‚ö†Ô∏è AUTH STORE: Resposta inesperada do servidor, mas mantendo sess√£o local')
        }
      } catch (serverError) {
        console.warn('‚ö†Ô∏è AUTH STORE: Erro ao verificar com servidor, mas mantendo sess√£o local:', {
          status: serverError.response?.status,
          message: serverError.message
        })
        
        // ‚úÖ IMPORTANTE: S√≥ limpar dados se for erro 401 (token inv√°lido)
        if (serverError.response?.status === 401) {
          console.error('üí• AUTH STORE: Token rejeitado pelo servidor (401), fazendo logout')
          clearAuthData()
          isLoading.value = false
          return false
        }
        
        // Para outros erros (500, network, etc), manter sess√£o local
        console.log('üîÑ AUTH STORE: Mantendo sess√£o local devido a erro de rede/servidor')
      }
      
      // ‚úÖ SUCESSO: Autentica√ß√£o inicializada
      isLoading.value = false
      console.log('üéâ AUTH STORE: Autentica√ß√£o inicializada com sucesso')
      return true
      
    } catch (error) {
      console.error('üí• AUTH STORE: Erro cr√≠tico ao inicializar autentica√ß√£o:', error)
      clearAuthData()
      isLoading.value = false
      return false
    }
  }

  // Alias para initializeAuth (compatibilidade)
  const checkAuth = async () => {
    return await initializeAuth()
  }
  
  const updateUserProfile = (userData) => {
    user.value = { ...user.value, ...userData }
    localStorage.setItem('user_data', JSON.stringify(user.value))
  }

  const refreshUserData = async () => {
    try {
      const response = await authAPI.me()
      if (response.data.success && response.data.user) {
        user.value = response.data.user
        localStorage.setItem('user_data', JSON.stringify(user.value))
        return true
      }
      return false
    } catch (error) {
      console.error('Erro ao atualizar dados do usu√°rio:', error)
      return false
    }
  }

  // Getter para verificar se h√° token v√°lido
  const hasValidToken = () => {
    const currentToken = token.value || localStorage.getItem('auth_token')
    return currentToken && !isTokenExpired(currentToken)
  }

  // Getter para obter o token atual
  const getCurrentToken = () => {
    return token.value || localStorage.getItem('auth_token')
  }
  
  return {
    // Estado
    user,
    token,
    isAuthenticated,
    isLoading,
    
    // Actions
    login,
    register,
    logout,
    initializeAuth,
    checkAuth,
    updateUserProfile,
    refreshUserData,
    clearAuthData,
    saveAuthData,
    
    // Getters
    hasValidToken,
    getCurrentToken
  }
})